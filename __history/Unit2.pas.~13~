unit Unit2;

interface

uses
  Vcl.Graphics, Vcl.Imaging.jpeg, Vcl.Controls, Vcl.ExtCtrls,
  System.SysUtils, System.Types, System.Math, System.SyncObjs, System.Threading,
  ocv.utils,
  ocv.comp.View,

  ocv.comp.Types, ocv.comp.Source,

  ocv.objdetect_c,

  ocv.cls.highgui,
  ocv.cls.core,
  ocv.cls.contrib,
  ocv.cls.Types,
  ocv.highgui_c, ocv.core_c, ocv.core.types_c,
  ocv.imgproc_c,
  ocv.imgproc.types_c;

function MatchTemplateWithHistogram(const SourceImg, TemplateImg: PIplImage; ImageView: TImage): integer;
function ParallelMatchTemplateWithHistogram(const SourceImg, TemplateImg: PIplImage; ImageView: TImage): integer;

implementation

// const
// NumBins = 256;
// Ranges: array[0..0] of array[0..1] of Float = ((0, 256));

// procedure AllocatePlanes(const Img: PIplImage; var Planes: array of PIplImage);
// begin
// for var I := 0 to High(Planes) do
// begin
// // Planes[i] := cvCreateImage(cvGetSize(Img), Img^.depth, 1);
// Planes[I] := cvCreateImage(cvGetSize(Img), IPL_DEPTH_8U, 1);
//
// end;
// end;

procedure NonMaximumSuppression(const Matches: array of TRect; const Scores: array of Double; Threshold: Double;
  var Suppressed: array of Boolean);
var
  I, J: integer;
  Intersection: TRect;
begin

  for I := 0 to High(Matches) do
  begin
    Suppressed[I] := False;
    for J := 0 to High(Matches) do
    begin
      if (I <> J) and (not Suppressed[J]) then
      begin
        if (Scores[I] < Scores[J]) and IntersectRect(Intersection, Matches[I], Matches[J]) then
        begin
          Suppressed[I] := True;
          Break;
        end;
      end;
    end;
  end;
end;

procedure CalculateHistogram(const Img: PIplImage; var Hist: PCvHistogram);
var
  // Planes: array [0 .. 2] of PIplImage;
  b, g, r: PIplImage;
  HistSize: integer;
  // PlaneArr: PCvArr;
  range_0: array [0 .. 1] of Float;
  ranges: pFloat;
begin
  if not Assigned(Img) then
    raise Exception.Create('Image is not assigned.');

  if (Img^.width <= 0) or (Img^.height <= 0) then
    raise Exception.Create('Invalid image dimensions.');

  range_0[0] := 0;
  range_0[1] := 256;
  ranges := @range_0;

  // Allocate memory for the image planes
  // AllocatePlanes(Img, Planes);
  // channel colors
  b := cvCreateImage(cvGetSize(Img), Img^.depth , 1); //IPL_DEPTH_8U
  g := cvCreateImage(cvGetSize(Img), Img^.depth, 1);
  r := cvCreateImage(cvGetSize(Img), Img^.depth, 1);

  if not Assigned(b) or not Assigned(g) or not Assigned(r) then
  begin
    if Assigned(b) then
      cvReleaseImage(b);
    if Assigned(g) then
      cvReleaseImage(g);
    if Assigned(r) then
      cvReleaseImage(r);
    raise Exception.Create('Failed to allocate memory for image planes.');
  end;

  // Split the image into separate color planes (B, G, R)
  // cvSplit(Img, Planes[0], Planes[1], Planes[2], nil);

  // Split the image into separate color planes (B, G, R)
  try
    cvSplit(Img, b, g, r, nil);
  except
    // Free allocated planes if cvSplit fails
    cvReleaseImage(b);
    cvReleaseImage(g);
    cvReleaseImage(r);
    raise Exception.Create('cvSplit failed.');
  end;

  HistSize := 256;

  Hist := cvCreateHist(1, @HistSize, CV_HIST_ARRAY, @ranges, 1);

  // Calculate the histogram for each plane and combine them
  // for var I := 0 to 2 do
  // begin
  // PlaneArr := PCvArr(Planes[I]);
  // cvCalcHist(PlaneArr, Hist, 0, nil);
  // end;
  cvCalcHist(b, Hist, 0, nil);
  cvCalcHist(g, Hist, 0, nil);
  cvCalcHist(r, Hist, 0, nil);

  cvNormalizeHist(Hist, 1.0);

  cvReleaseImage(b);
  cvReleaseImage(g);
  cvReleaseImage(r);
end;

function CompareHistograms(const Hist1, Hist2: PCvHistogram): Double;
begin
  Result := cvCompareHist(Hist1, Hist2, CV_COMP_CORREL);
end;

function MatchTemplateWithHistogram(const SourceImg, TemplateImg: PIplImage; ImageView: TImage): integer;
var
  // SourceImg, TemplateImg,
  ResultImg: PIplImage;
  ResultWidth, ResultHeight: integer;
  TemplateHist, CandidateHist: PCvHistogram;
  HistScore: Double;
  ThresholdValue: Double;
  Matches: array of TRect;
  Scores: array of Double;
  Suppressed: array of Boolean;
  tmpBitmap: TBitmap;

begin
  // Load source and template images
  // SourceImg := cvLoadImage(PAnsiChar(AnsiString(SourceFile)), CV_LOAD_IMAGE_COLOR);
  // TemplateImg := cvLoadImage(PAnsiChar(AnsiString(TemplateFile)), CV_LOAD_IMAGE_COLOR);

  if Assigned(SourceImg) and Assigned(TemplateImg) then
  begin
    // Calculate histogram for the template image
    CalculateHistogram(TemplateImg, TemplateHist);

    // Create result image
    ResultWidth := SourceImg^.width - TemplateImg^.width + 1;
    ResultHeight := SourceImg^.height - TemplateImg^.height + 1;
    ResultImg := cvCreateImage(cvSize(ResultWidth, ResultHeight), IPL_DEPTH_32F, 1);

    // Perform template matching using CV_TM_CCOEFF_NORMED method
    cvMatchTemplate(SourceImg, TemplateImg, ResultImg, CV_TM_CCOEFF_NORMED);

    // Initialize arrays for matches and scores
    SetLength(Matches, 0);
    SetLength(Scores, 0);

    // Set a threshold value for histogram comparison scores
    ThresholdValue := 0.8;

    // Access the result image data as floats directly
    for var Row := 0 to ResultImg^.height - 1 do
    begin
      for var Col := 0 to ResultImg^.width - 1 do
      begin
        // Define the candidate region in the source image

        cvSetImageROI(SourceImg, cvRect(Col, Row, TemplateImg^.width, TemplateImg^.height));

        // Calculate histogram for the candidate region
        CalculateHistogram(SourceImg, CandidateHist);
        cvResetImageROI(SourceImg);

        // Compare histograms
        HistScore := CompareHistograms(TemplateHist, CandidateHist);

        // Free the candidate histogram
        cvReleaseHist(CandidateHist);

        if HistScore >= ThresholdValue then
        begin
          // Store the match location and score
          SetLength(Matches, Length(Matches) + 1);
          Matches[High(Matches)] := Rect(Col, Row, Col + TemplateImg^.width, Row + TemplateImg^.height);
          SetLength(Scores, Length(Scores) + 1);
          Scores[High(Scores)] := HistScore;
        end;
      end;
    end;

    // Allocate Suppressed array
    SetLength(Suppressed, Length(Matches));

    // Apply Non-Maximum Suppression to reduce false positives
    NonMaximumSuppression(Matches, Scores, ThresholdValue, Suppressed);

    // Draw rectangles around non-suppressed matches
    Result := 0;
    for var I := 0 to High(Matches) do
    begin
      if not Suppressed[I] then
      begin
        inc(Result);
        cvRectangle(SourceImg, cvPoint(Matches[I].Left, Matches[I].Top), cvPoint(Matches[I].Right, Matches[I].Bottom),
          CV_RGB(255, 0, 0), 2, 8, 0);
      end;
    end;

    // Display the source image with all matches in TOcvView
    tmpBitmap := TBitmap.Create;

    tmpBitmap.PixelFormat := pf24bit;
    tmpBitmap.height := SourceImg.height;
    tmpBitmap.width := SourceImg.width;
    try
      IplImage2Bitmap(SourceImg, tmpBitmap);
      ImageView.Picture.Assign(tmpBitmap);
    finally
      tmpBitmap.Free;
    end;

    // Release images and histograms
    // cvReleaseImage(SourceImg);
    // cvReleaseImage(TemplateImg);
    cvReleaseImage(ResultImg);
    cvReleaseHist(TemplateHist);
  end;
end;

function ParallelMatchTemplateWithHistogram(const SourceImg, TemplateImg: PIplImage; ImageView: TImage): integer;
var
  ResultImg: PIplImage;
  ResultWidth, ResultHeight: integer;
  TemplateHist: PCvHistogram;
  Matches: TArray<TRect>;
  Scores: TArray<Double>;
  Suppressed: TArray<Boolean>;
  tmpBitmap: TBitmap;
  ThresholdValue: Double;
  CriticalSection: TCriticalSection;
  Tasks: array of ITask;
  TaskResults: array of TArray<TRect>;
  TaskScores: array of TArray<Double>;

begin
  Result := 0;
  CriticalSection := TCriticalSection.Create;
  try
    if Assigned(SourceImg) and Assigned(TemplateImg) then
    begin
      CalculateHistogram(TemplateImg, TemplateHist);

      ResultWidth := SourceImg^.width - TemplateImg^.width + 1;
      ResultHeight := SourceImg^.height - TemplateImg^.height + 1;
      ResultImg := cvCreateImage(cvSize(ResultWidth, ResultHeight), IPL_DEPTH_32F, 1);

      ThresholdValue := 0.8;

      SetLength(Tasks, ResultImg^.height);
      SetLength(TaskResults, ResultImg^.height);
      SetLength(TaskScores, ResultImg^.height);

      for var rowIndex := 0 to ResultImg^.height - 1 do
      begin
        Tasks[rowIndex] := TTask.Create(
          procedure
          var
            Col: integer;
            CandidateHist: PCvHistogram;
            HistScore: Double;
            LocalMatches: TArray<TRect>;
            LocalScores: TArray<Double>;
          begin
            for Col := 0 to ResultImg^.width - 1 do
            begin
              cvSetImageROI(SourceImg, cvRect(Col, rowIndex, TemplateImg^.width, TemplateImg^.height));
              CalculateHistogram(SourceImg, CandidateHist);
              cvResetImageROI(SourceImg);

              HistScore := CompareHistograms(TemplateHist, CandidateHist);
              cvReleaseHist(CandidateHist);

              if HistScore >= ThresholdValue then
              begin
                LocalMatches := LocalMatches + [Rect(Col, rowIndex, Col + TemplateImg^.width,
                  rowIndex + TemplateImg^.height)];
                LocalScores := LocalScores + [HistScore];
              end;
            end;

            CriticalSection.Enter;
            try
              TaskResults[rowIndex] := LocalMatches;
              TaskScores[rowIndex] := LocalScores;
            finally
              CriticalSection.Leave;
            end;
          end);
        Tasks[rowIndex].Start;
      end;

      TTask.WaitForAll(Tasks);

      for var I := 0 to High(TaskResults) do
      begin
        Matches := Matches + TaskResults[I];
        Scores := Scores + TaskScores[I];
      end;

      SetLength(Suppressed, Length(Matches));
      NonMaximumSuppression(Matches, Scores, ThresholdValue, Suppressed);

      for var I := 0 to High(Matches) do
      begin
        if not Suppressed[I] then
        begin
          inc(Result);
          cvRectangle(SourceImg, cvPoint(Matches[I].Left, Matches[I].Top), cvPoint(Matches[I].Right, Matches[I].Bottom),
            CV_RGB(255, 0, 0), 2, 8, 0);
        end;
      end;

      tmpBitmap := TBitmap.Create;
      try
        tmpBitmap.PixelFormat := pf24bit;
        tmpBitmap.height := SourceImg^.height;
        tmpBitmap.width := SourceImg^.width;
        IplImage2Bitmap(SourceImg, tmpBitmap);
        ImageView.Picture.Assign(tmpBitmap);
      finally
        tmpBitmap.Free;
      end;

      cvReleaseImage(ResultImg);
      cvReleaseHist(TemplateHist);
    end;
  finally
    CriticalSection.Free;
  end;
end;

end.
