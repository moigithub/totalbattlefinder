unit Unit3;

interface

uses Vcl.Imaging.jpeg, Vcl.Controls, Vcl.ExtCtrls,
  OPENCVWrapper, Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes,
  Vcl.Forms, Vcl.Dialogs, Vcl.ExtDlgs, Vcl.Graphics, Vcl.StdCtrls,
  System.Generics.Collections;


procedure PerformTemplateMatching(FileName: string; image: TImage);

implementation

uses unit1;
type
  TDetection = class
    confidence: Double;
    classId: Integer;
    box: TRect;
    nsmValid: Boolean;
  end;

var
  NMS_THRES: Single = 0.5;

procedure CaptureDesktop(var Bitmap: TBitmap);
var
  ScreenDC: HDC;
  ScreenWidth, ScreenHeight: Integer;
begin
  ScreenWidth := GetSystemMetrics(SM_CXSCREEN);
  ScreenHeight := GetSystemMetrics(SM_CYSCREEN);

  // Bitmap.SetSize(ScreenWidth, ScreenHeight);
  Bitmap.Width := ScreenWidth;
  Bitmap.Height := ScreenHeight;
  Bitmap.PixelFormat := pf24bit;

  ScreenDC := GetDC(0);
  try
    BitBlt(Bitmap.Canvas.Handle, 0, 0, ScreenWidth, ScreenHeight, ScreenDC, 0, 0, SRCCOPY);
  finally
    ReleaseDC(0, ScreenDC);
  end;
end;

function LoadImage(const FileName: string): pCvMat_t;
var

  sfile: CvString_t;
begin
  sfile.pstr := PAnsiChar(AnsiString(FileName));

  Result := pCvimread(@sfile, ord(IMREAD_COLOR));
  if Result = nil then
    raise Exception.Create('Failed to load image: ' + FileName);
end;

function MatchTemplate(const SourceImg, TemplateImg: pCvMat_t): pCvMat_t;
var
  ResultImg: pCvMat_t;
  ResultWidth, ResultHeight: Integer;
begin

  // pCvCvtColor(internImage, colorImg, Ord(COLOR_GRAY2BGR));
  // MatImage2Bitmap(colorImg, bmp);
  // pCvMatDelete(colorImg);

  ResultWidth := pCvMatGetWidth(SourceImg) - pCvMatGetWidth(TemplateImg) + 1;
  ResultHeight := pCvMatGetHeight(SourceImg) - pCvMatGetHeight(TemplateImg) + 1;

  ResultImg := pCvMatImageCreate(ResultWidth, ResultHeight, CV_8UC3); // CV_32FC1

  pcvmatchTemplate(SourceImg, TemplateImg, ResultImg, ord(TM_CCOEFF_NORMED));
  Result := ResultImg;
end;

function DrawRectangleOnMatch(const SourceImg, ResultImg: pCvMat_t; const TemplateImg: pCvMat_t): pCvMat_t;
var
  MinVal, MaxVal: Double;
  MinLoc, MaxLoc: pCvPoint_t;
  ppts: pCvPoint_t;
  pts: CvPointS;
  windowName: string;
  cvstr: CvString_t;
begin
  MinLoc := pCvPointCreate();
  MaxLoc := pCvPointCreate();
  pcvminMaxLoc(ResultImg, @MinVal, @MaxVal, MinLoc, MaxLoc, nil);
  pCvPointToStruct(MaxLoc, @pts);
  ppts := cvPoint_(pts.x + pCvMatGetWidth(TemplateImg), pts.y + pCvMatGetHeight(TemplateImg));
  pcvrectangle(SourceImg, MaxLoc, ppts, cvScalar_(0, 255, 0, 0), 4, 8, 0);

  Result := SourceImg;
  // windowName := 'Matched Result';
  // cvstr.pstr := PAnsiChar(AnsiString(windowName));
  // pcvimshow(@cvstr, SourceImg);
  // pcvwaitKey(0);
  // pcvdestroyWindow(@cvstr);
end;

function GetBoundingBoxes(ResultImg, TemplateImg: pCvMat_t; threshold: Double ): TList<TDetection>;
var
  x,y,i,j: Integer;
  fX, fY: Integer;
  conf: Single;
  scores: pCvMat_t;    outColor: PCvMat_t;
  dptr: UInt64;
  outptr: UInt64;
  outW, outH: Integer;
  detections: TList<TDetection>;
  detect: TDetection;
  matdims: array [0 .. 3] of Integer;
  minclassscore, maxclassscore: Double;
  cx, cy, rw, rh: Single;
  MaxLoc: pCvPoint_t;
  pts: CvPointS;

  DesktopBitmap:TBitmap;

begin
  dptr := pCvMatGetData(ResultImg);
  outW := pCvMatGetWidth(ResultImg);
  outH := pCvMatGetHeight(ResultImg);
  fX := pCvMatGetWidth(TemplateImg);
  fY := pCvMatGetHeight(TemplateImg);
  matdims[0] := 256;
  matdims[1] := 256;

  detections := TList<TDetection>.Create;

  {
    // creo q podria ser asi

   //   MinLoc := pCvPointCreate();
  MaxLoc := pCvPointCreate();


    for j := 0 to outH - 1 do
    begin
    //conf := PSingle(dptr + 4 * SizeOf(Single))^;




    // Slice heatmap of corresponding body's part.
    outptr:=pCvMatGetDimPtr(ResultImg, 0, j);
    scores:=pCvMatCreate(1, @matdims[0],  CV_32FC1, outptr);   // CV_32F(NO)  CV_32FC1   CV_8UC3 (NO)

//   test
//    outColor:=pCvMatCreateEmpty;
//    pCvMatConvertTo(scores, outColor, CV_8UC1);
//   pCvcvtColor(outColor, outColor, Ord(COLOR_RGB2BGR));
//
//          DesktopBitmap := TBitmap.Create;
//          DesktopBitmap.PixelFormat := pf24bit;
//          DesktopBitmap.Width:=300;
//          DesktopBitmap.Height:=300;
//        MatImage2Bitmap(outColor, DesktopBitmap);
//    form1.image3.Picture.Assign(DesktopBitmap);
//         fin test



    // scores := pCvMatCreate(1, @matdims[0], CV_32FC1, (dptr + 5 * SizeOf(Single)));

   // pcvminMaxLoc(scores, @minclassscore, @maxclassscore, nil, MaxLoc);
    pcvminMaxLoc(scores, @minclassscore, @maxclassscore, nil, MaxLoc, nil);
    if maxclassscore >= threshold then
    begin


      pCvPointToStruct(MaxLoc, @pts);
     // ppts := cvPoint_(pts.x + pCvMatGetWidth(TemplateImg), pts.y + pCvMatGetHeight(TemplateImg));
     // pcvrectangle(SourceImg, MaxLoc, ppts, cvScalar_(0, 255, 0, 0), 4, 8, 0);

      detect := TDetection.Create;
      //pCvPointToStruct(MaxLoc, @pts);
      detect.confidence := maxclassscore;
      detect.classId := pts.y;
//      cx := pts.x;
//      cy := pts.y;
//      rw := pts.x + pCvMatGetWidth(TemplateImg);
//      rh := pts.y + pCvMatGetHeight(TemplateImg);

      detect.box.Left :=  pts.x;
      detect.box.Top := pts.y;
      detect.box.Width :=   pCvMatGetWidth(TemplateImg);
      detect.box.Height := pCvMatGetHeight(TemplateImg);
      detect.nsmValid := False;

      detections.add(detect);

    end;
    pCvMatDelete(scores);
    end;
    }



     for y := 0 to outH - 1 do   //rows   = height
      for x:= 0 to outW - 1 do   //cols   = width
  begin
    conf := PSingle(dptr + (x  + (y * outW)) * sizeof(single))^;
//  conf:=PSingle(dptr)^;
//     dPtr:=dPtr+sizeof(single);
    // dptr := dptr + outW * SizeOf(Single);
    if conf >= threshold then
    begin
      // Slice heatmap of corresponding body's part.
      // outptr:=pCvMatGetDimPtr(ResultImg, 0, j);
      // scores:=pCvMatCreate(1, @matdims[0],  CV_32FC1, outptr);

//      scores := pCvMatCreate(1, @matdims[0], CV_32FC1, (dptr + 5 * SizeOf(Single)));

//      pcvminMaxLoc(scores, @minclassscore, @maxclassscore, nil, MaxLoc);
      // begin
      detect := TDetection.Create;
//      pCvPointToStruct(MaxLoc, @pts);
      detect.confidence := conf;
      detect.classId := pts.y;


      detect.box.Left := x;
      detect.box.Top :=y;
      detect.box.Width :=  fX;
      detect.box.Height :=   fY ;
      detect.nsmValid := False;

      detections.add(detect);
      // end;

      pCvMatDelete(scores);
    end;
   // dptr := dptr + outW * SizeOf(Single);
  end;



  {
  for j := 0 to outH - 1 do   //rows
  begin
    conf := PSingle(dptr + 4 * SizeOf(Single))^;

    if conf >= threshold then
    begin
      // Slice heatmap of corresponding body's part.
      // outptr:=pCvMatGetDimPtr(ResultImg, 0, j);
      // scores:=pCvMatCreate(1, @matdims[0],  CV_32FC1, outptr);

      scores := pCvMatCreate(1, @matdims[0], CV_32FC1, (dptr + 5 * SizeOf(Single)));

      pcvminMaxLoc(scores, @minclassscore, @maxclassscore, nil, MaxLoc);
      // begin
      detect := TDetection.Create;
      pCvPointToStruct(MaxLoc, @pts);
      detect.confidence := maxclassscore;
      detect.classId := pts.y;
      cx := PSingle(dptr)^;
      cy := PSingle(dptr + 1 * SizeOf(Single))^;
      rw := PSingle(dptr + 2 * SizeOf(Single))^;
      rh := PSingle(dptr + 3 * SizeOf(Single))^;

      detect.box.Left := Round((cx - 0.5 * rw) * fX);
      detect.box.Top := Round((cy - 0.5 * rh) * fY);
      detect.box.Width := Round(rw * fX);
      detect.box.Height := Round(rh * fY);
      detect.nsmValid := False;

      detections.add(detect);
      // end;

      pCvMatDelete(scores);
    end;
    dptr := dptr + outW * SizeOf(Single);
  end;
   }
  Result := detections;
end;

//function DrawRectangleOnMultipleMatch(const SourceImg, ResultImg: pCvMat_t; const TemplateImg: pCvMat_t): pCvMat_t;
//var
//
//  detections: TList<TDetection>;
//   detect: TDetection;
//   threshold: Single;
//
//   i,j: Integer;
//
//  vecBoxes: PCvvector_Rect2d;
//  vecScores: PCvvector_float;
//  box2d: PCvRect2d_t;
//  scalparm: PCvScalar_t;
//  pta, ptb: pCvPoint_t;
//  vecNmsIndex: PCvvector_int;
//  nmsNr: Integer;
//begin
//  threshold := 0.7;
//  detections :=    GetBoundingBoxes(ResultImg, TemplateImg, threshold );
//
//  // Non Maxima Suppression (NMS) delete overlapped boxes with equal class
//  vecBoxes := pCvVectorRect2dCreate(detections.Count);
//  vecScores := pCvVectorfloatCreate(detections.Count);
//  i := 0;
//  for detect in detections do
//  begin
//    box2d := CvRect2d_(detect.box.Left, detect.box.Top, detect.box.Width, detect.box.Height);
//    pCvVectorRect2dSet(vecBoxes, i, box2d);
//    pCvVectorfloatSet(vecScores, i, detect.confidence);
//    Inc(i);
//  end;
//  vecNmsIndex := pCvVectorintCreate(0);
//  pCvdnn_NMSBoxes(vecBoxes, vecScores, threshold, NMS_THRES, vecNmsIndex);
//  nmsNr := pCvVectorintLength(vecNmsIndex);
//  for i := 0 to nmsNr - 1 do
//  begin
//    detections.Items[pCvVectorintGet(vecNmsIndex, i)].nsmValid := True;
//  end;
//
//  pta := pCvPointCreate();
//  ptb := pCvPointCreate();
//  scalparm := cvScalar_(0, 255, 0, 0);
//  for detect in detections do
//  begin
//    // not valid after NMS calculation
//
//
//
//
////    if detect.nsmValid = False then
////      Continue;
//
//
//
//
//
//    pta := cvPoint_(detect.box.TopLeft.x, detect.box.TopLeft.y, pta);
//    ptb := cvPoint_(detect.box.BottomRight.x, detect.box.BottomRight.y, ptb);
//    pcvrectangle(SourceImg, pta, ptb, scalparm, 2);
//
//    // classLabel:=Format('%s %4.2f %%',  [classes.Strings[detect.classId], (detect.confidence*100)]);
//    // cvstr.pstr:=PAnsiChar(AnsiString(classLabel));
//    // labelSize:=pCvgetTextSize(@cvstr, Ord(FONT_HERSHEY_SIMPLEX), 0.8, 2, @baseline);
//    // pCvputText(img, @cvstr, pta, ord(FONT_HERSHEY_SIMPLEX), 0.8, scalparm);
//  end;
//
//
//  //cleanup
//  for i := 0 to detections.Count - 1 do
//begin
//  TDetection(detections[i]).Free;  // Type cast
//end;
//
//
//   Result := SourceImg;
//end;
//

procedure PerformTemplateMatching(FileName: string; image: TImage);
var
  DesktopBitmap: TBitmap;
  SourceImg, TemplateImg, ResultImg: pCvMat_t;
  TemplateFileName: string;
begin
  DesktopBitmap := TBitmap.Create;
  try
    // Capture the desktop image
    CaptureDesktop(DesktopBitmap);

    // Convert the captured image to OpenCV Mat
    // SourceImg:=pCvMatCreateEmpty();
    // pCvMatConvertTo(SourceImg, SourceImg, CV_8U);
    SourceImg := pCvMatImageCreate(DesktopBitmap.Width, DesktopBitmap.Height, CV_8UC3);
    Bitmap2MatImage(SourceImg, DesktopBitmap);

    // Load the template image
    TemplateFileName := FileName;
    TemplateImg := LoadImage(TemplateFileName);

    // Perform template matching
    ResultImg := MatchTemplate(SourceImg, TemplateImg);

    // Draw rectangle on match and display result
    SourceImg := DrawRectangleOnMatch(SourceImg, ResultImg, TemplateImg);

//    SourceImg :=DrawRectangleOnMultipleMatch(SourceImg, ResultImg, TemplateImg);

    MatImage2Bitmap(SourceImg, DesktopBitmap);
    image.Picture.Assign(DesktopBitmap);

    // Release images

    pCvMatDelete(SourceImg);
    pCvMatDelete(TemplateImg);
    pCvMatDelete(ResultImg);
  finally
    DesktopBitmap.Free;
  end;
end;

end.
